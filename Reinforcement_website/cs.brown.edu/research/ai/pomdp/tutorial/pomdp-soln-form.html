<HTML>
<HEADER>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; Linux 2.1.123 i586) [Netscape]">
   <META NAME="Author" CONTENT="Anthony R. Cassandra">
   <META NAME="Keywords" CONTENT="POMDP, Markov, Planning, decision theory">
   <TITLE>POMDPs for Dummies: Page 7</TITLE>
</HEADER>
<BODY TEXT="#F0F0F0" BGCOLOR="#003300" LINK="#F8D900" VLINK="#CCCCCC" ALINK="#00FF00">

<CENTER><FONT SIZE="-1"><B>
<A HREF="pomdp-vi-example.html">Back</A>
| <A HREF="index.html">POMDP Tutorial</A>
| <A HREF="monahan.html">Next</A>
</B></FONT></CENTER>

<P>
<IMG SRC="images/brown-clear.gif" HEIGHT=111 WIDTH=102 ALIGN=LEFT>

<CENTER><IMG SRC="images/oak-a-stripe.gif"></CENTER>

<CENTER><H1>General Form of a POMDP solution</H1></CENTER>

<CENTER><IMG SRC="images/oak-a-stripe.gif"></CENTER>

<P>
We now summarize and generalize the ideas presented in the above
example.  The lines in the two state value functions become
hyper-planes in the general case.  Since we can represent a hyper-plane
with a vector of its coefficients, our value function can (and will)
be represented with a set of vectors. <p>

To define some notation, let <tt>V'</tt> be the set of vectors we
desire for the next stage of value iteration and <tt>V</tt> be the set
of vectors we have from the previous stage. Here the stages of value
iteration simply correspond to succeeding horizon lengths. <p>

As we saw in the example, each vector in <tt>V'</tt> is constructed from
a combination of vectors in <tt>V</tt>.  More precisely each vector is
constructed from the immediate rewards and the transformation (using
the <tt>S()</tt> functions) of <tt>V</tt>. <p>

A vector in <tt>V</tt> has a particular strategy associated with it.
Each vector at a stage represents the value of acting according to the
particular current and future strategy for that vector.  Selecting a
vector at a stage is the same as selecting a particular course of
action at a stage and a particular future action strategy.  The future
strategy is contingent upon the particular observations that are
received, but for a particular observation sequence the future
strategy is fixed.  <p>

When we are given the set of vectors, it is easy to decide how to act
for a given belief state; just select the action associated with the
vector that gives the highest value at that point.  Our problem is to
construct those vectors, <tt>V'</tt>, given that we know the best ways
to act in the previous stage, which is what <tt>V</tt> tells us.  <p>

Each action we perform has some immediate and some future
consequences.  The immediate consequences are directly available from
the <tt>POMDP</tt> problem formulation.  The future consequences are
completely contained in the set <tt>V</tt>.  However, things change
when we perform an action, so all the possible future consequences
must be weighted by the probability that we will incur those
consequences.  These probabilities come directly from the
<tt>POMDP</tt> formulation and, more specifically, depend upon our
current belief, the immediate action we take and the observation that
the world provides us.  <p>

Again without going into the formulas, suffice it to say that we can
take the set <tt>V</tt> and transform it into a set <tt>S(a,z)</tt>
for each action, <tt>a</tt>, and observation, <tt>z</tt>. Think of
each of these sets as the effect of choosing the the various courses
of action for the vectors in <tt>V</tt> after having performed action
<tt>a</tt> and having seen observation <tt>z</tt>.  Constructing each
of the sets <tt>\S(a,z)</tt> is a simple transformation using the
set <tt>V</tt> and the <tt>POMDP</tt> model parameters.  <p>

Once transformed into <tt>S(a,z)</tt> it is easy to see which
vector in <tt>V</tt> has the best future course of action, given that
our immediate action was <tt>a</tt> and immediate observation was
<tt>z</tt>.  In fact, the vectors in <tt>S(a,z)</tt> also form a
piecewise linear convex value function over belief space.  Note that
if we look at the partition of <tt>S(a,z)</tt> and the partition
of <tt>V</tt> they are not usually the same.  <p>

<center>
<img src="figs/transformed-v.gif">
<h3>Figure 4: Transformed V for a and z</h3>
</center>

Note that a point in the function <tt>V</tt> is how good it is to
follow that strategy if our belief was this point, whereas a point in
the transformed value function is how good it is to follow that
strategy, given we started at that point, performed action <tt>a</tt>
and saw observation <tt>z</tt>.  <p>

We now come back to our main problem: how to construct the vectors in
<tt>V'</tt> from the set <tt>V</tt>.  One key point to many of the
solution procedures is that given a particular belief point, we can
easily construct the vector in <tt>V'</tt> for that belief point.  This
may not be completely obvious without any formulas, but it actually
easy to show how with our partition view of the sets of vectors.  <p>

Below is a picture of the <tt>S(a,z)</tt> partitions of belief space
for a particular action, with each observation, one on top of the
other.  <p>

<center>
<img src="figs/obs-partitions2.gif">
<h3>Adjacent belief partitions for transformed value function</h3>
</center>

For each action we can perform, we could see any of the possible
observations after doing this.  For a given action, we need to look at
the immediate effects of the action and select a future course of
action for each possible observation we can get.  Ignoring the
immediate effects for the moment, we actually have the information we
need to select a course of action for each observation; the sets
<tt>S(a,z)</tt>.  <p>

For a given observation, the choice of action is obvious at a given
belief point.  The vector that dominates is the one to choose and this
is already worked out for us in the partitioning diagram, because it
shows where each vector dominates.  For all the observations we do the
same and it amounts to drawing a vertical line corresponding to a
belief point and selecting all the vectors whose partition it
intersects. <p>

<center>
<img src="figs/partition-point2.gif">
<h3>Point through the transformed value function's partitions
construction</h3>
</center>

This selection process is giving us a kind of contingency strategy.
It tells us which <tt>V</tt> vector to choose for each observation,
which amounts to telling us which future course of action is best. <p>

So for a particular action, given a belief point the vector we are
interested in is comprised of the immediate effects of the action plus
the sum of all of the chosen vector from each of the sets
<tt>S(a,z)</tt>.  We must also add the immediate reward effects for that
particular action.  <p>

However, the vector constructed this way may or may not be in
<tt>V'</tt>.  We actually need to construct a vector at this point for
each action and determine which one is the dominant one.  The dominant
one belongs to the set <tt>V'</tt> and its course of action is
associated with it.  The strategy that that vector represents is that
immediate action, plus the future strategies from the <tt>V</tt>
vectors chosen.  Since we selected a different vector for each
observation, the future strategy is contingent upon the observation we
get. <p>

If it were possible to enumerate all the belief points, we could
construct all the vectors this way.  Many belief points would produce
duplicate vectors, but we could discard those and be left with the set
we wanted.  Since enumerating belief points is not possible, we must
be smarter about generating these vectors.  Since we know there are
only a finite number of vectors, there exists a finite set of points
that would allow us to generate each vector.  The problem is that we
don't immediately have access to this set. <p>

Displaying the partitioning of the transformed <tt>V</tt> actually
make it easy for us to pick out the vectors by eye.  The figure below
shows how just need to inspect the partitions to see where there is a
different combination of vectors we could choose.  We look at each
observation and select a color, the number of different combination
are the number of vectors that will be in the value function for this
particular action <tt>a</tt>. <p>

<center>
<img src="figs/combined-regions.gif">
<h3>Making a new partition from S(a,z) partitions</h3>
</center>

This is easy when we have a simple two state <tt>POMDP</tt> and these
nice partitioning pictures.  To do this automatically for a
<tt>POMDP</tt> with a lot of states is not so easy.  We can visually
inspect the partition diagrams and pick out the number of regions, and
we know immediately how to combine the transformed <tt>V</tt> vectors
to create the new vectors.  However, in higher dimensional space it
will be very hard to apply this same sort of visual inspection.  All
we really need is a single point in each of the regions, but knowing
the regions or the set of points we need is not such as easy task. <p>

<center><h2><a href="./monahan.html">Continue</a></h2></center>

<P>
<CENTER><IMG SRC="images/oak-a-stripe.gif"></CENTER>
<P>

<CENTER><FONT SIZE="-1"><B>
<A HREF="pomdp-vi-example.html">Back</A>
| <A HREF="index.html">POMDP Tutorial</A>
| <A HREF="monahan.html">Next</A>
</B></FONT></CENTER>

</BODY>
</HTML>
